<!--

<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

    Author:     Jason Novotny
    Version:    $Id$
-->

<chapter id="portlet-persistence">
    <title>Portlet Persistence</title>
    <para>
        GridSphere provides a persistence framework implemented using &Hibernate; Persistence Layer.
        It provides methods to store objects to a SQL based database and supports many database types.
    </para>
    <sect1>
        <title>Configuration</title>
        The configurationfile for the PersistenceManager is
        <filename>$GRIDSPHERE_SOURCE/webapps/gridsphere/WEB-INF/persistence/hibernate.properties</filename>.
        For the available configurationoptions please see the &Hibernate; website. By default it is configured
        GridSphere by default is configured to use HSQL, a pure Java in-memory database useful for testing and development.
        For a production environment we strongly recommend to use a standalone database such as MySQL.
    </sect1>
    <sect1>
        <title>Simple Persistence</title>
        <para>
            In general when requiring persistence in a portlet, first see if the
            <link linkend='portlet.data'>&PortletData;</link> object can meet your needs. Although, it only provides
            a container for simple &String; key/value pairs it can go a long way.
            <informalexample>
                <programlisting>
                    PortletData pd = request.getData();
                    pd.setAttribute("key", value);
                    try {
                    pd.store();
                    } catch (IOException e) {
                    // something went wrong while storing the data!
                    }
                </programlisting>
            </informalexample>
            This would store the String value under the key 'key'. Getting data back is as easy
            as storing data. If no value is found <classname>null</classname> is returned.
            <informalexample>
                <programlisting>
                    PortletData pd = request.getData();
                    String value = pd.getAttribute("key");
                </programlisting>
            </informalexample>
            PortletData saved values are on a per user basis.

        </para>
    </sect1>
    <sect1>
        <title>The Persistence Manager</title>
        <para>
            The
            <classname>PersistenceManagerRdbms</classname> interface defines methods for retrieving, creating, updating
            and deleting objects from the database. A
            <classname>PersistenceManagerException</classname> is thrown in the
            case that an error occurs.
        </para>
        <sect2>
            <title>Mapping files</title>
            <para>
                In order to persistent your own objects you need to write hibernate mapping files.
                These have go into the
                <filename>$PROJECT_ROOT/webapp/persistence</filename> directory. This can be either one file or multiple files.
            </para>
        </sect2>
        <sect2>
            <title>Usage</title>
            <para>
                In the case that a portlet requires more sophisticated storage, the best approach is to create a separate
                portlet service for this management. See
                <link linkend='portlet-service-example' endterm="portlet-service-example-title"/>
                The following listing illustrates the storage/retrieval/update of an object to the database using the persitence manager.
            </para>
            <informalexample>
                <programlisting linenumbering="numbered">

                    PersistenceManagerRdbms pm =
                    PersistenceManagerFactory.createPersistenceManagerRdbms(<emphasis>"webappname"</emphasis>);

                    data.setName("test");

                    // store persistent data
                    pm.store(data);

                    // now retrieve it
                    PMData testdata = (PMData)pm.restore("from PMData where name='test'");

                    // modify it
                    testdata.setName("test2");

                    // update
                    pm.update(testdata);

                </programlisting>
            </informalexample>
            <para>
                This example persists the 'data' object. The <methodname>restore</methodname> method will restore the first object from
                the storage matching the given criteria. If you do want to restore a list of object you need
                to use <methodname>restorelist</methodname> instead.
            </para>
        </sect2>
        <sect2>
            <title>Storing data on a user behalf</title>
            If you do want to store data on behalf of the user (such like a history of commands) you
            have to modify your objects you want to store. In pure Hibernate you would simply just stick
            the <classname>user</classname>object in there. Since the <classname>user</classname>object is
            immutable for third party webapps and the way &Hibernate; works you have to use another method
            to store data.
            Every <classname>user</classname>object has a unique ID attached to it. The recommned way is that
            you creating a variable along with getter/setter methods in your class which you want to make
            persistent. The class would have information like this:
            <informalexample>
                <programlisting linenumbering="numbered">
                    ...
                    private String useroid = null;

                    public String getUseroid() {
                        return useroid;
                    }

                    public void setUseroid(String useroid) {
                        this.useroid = useroid;
                    }
                    ...
                </programlisting>
            </informalexample>
            The referring mappingfile would need one more line to save this information.
            <informalexample>
                <programlisting linenumbering="numbered">
                    property name="Useroid" type="string" column="userid"/
                </programlisting>
            </informalexample>
            Now you can store and update your data. To restore it you owuld have to use something like:
            <informalexample>
                <programlisting linenumbering="yes">
                    User user = request.getUser();
                    result = (MyClass)pm.restore("from "+MyClass.class.getName()+" as sub where sub.Useroid='"+user.getID()+"'");

                </programlisting>
            </informalexample>
        </sect2>

    </sect1>



    <!-- - create : creates a new object
    - restoreObject : restores a single object matchin the query in
      rdbms (aka the first found object) , in xml one xml files
      represents one object it will return the object
    - restoreList : returns a list object conntaining all objects
      which matches the query (rdbms) in xml it returns a list with
      just on object (maybe never used this function, I just put it
      there)
    - delete : deletes object from storage (rdbms), in xml it does nothing
      until now (should delete the file)
    - update : updates the object on the storage

    These methods are in the interface, further more there is

    - setConnectionURL : in rdbms sets the filename of the database.xml file,
      in xml sets the filename to the xml file where you want to have your
      data saved


    In rdbms you need two more methods:

    - setDatabaseName : which database to save to (like 'portal')
    - setQuery : sets the actual query

    The CRUD methods are throwing exception, every one throws
    ConfigurationException if the configuration was not ok (like
    connectionURL was not set) and Create/Restore/Update/Delete
    Exception (only in the corresponding methods of course)

    If you want to store your data in a rdbms (like mysql) and want
    to not direclty code in castor syntax you have to extend from
    BaseObject (or implement the methods and variables there).
    Every objects needs an ObjectID (Oid) and for castortransactions
    the field timestamp is needed. For my classes I assume Oid and
    timestamp exists in every class which should be saved to a rdbms.
    You don't need this if you want to save to xml.
    Fuurthermore you need to 'normalize' your classes to store them in
    a database and structures like vector and list are not directly
    saved in the object itself but in a seperate table (since these
    structures can only be represented in a database as a table and
    table in table is not possible, but table with a reference to another
    table). Let's assume you have an Object Users, with a vector
    of computername of this user.

    public class User {
       private String name;
       private Vector ListOfComputers;

       get/set...

    }

    The database table for user would look like:

    Oid varchar(255), Name varchar(255)...but waht about the list?

    The ListOfComputers must be stored in a sperate table, actually it should
    have the name 'Computer'.

    Oid varchar(255), Name varachr(255), UserOid varchar(255)

    So every entry in the table ListOfComputers would have
    an Oid, the name of the computer and the reference to the User.
    What does this mean for the User Object, it should look like this:

    public class User {
        private String name;
        private Vector ListOfComputers;

        get/set Name

        public void addComputer(String name) {
           Computer comp = new Computer(name);
           comp.setOwner(this.name);
           persistencemanger.save(comp);
        }

        public void getComputers() {

           Vector list = persistencemanager.getList(query database for all computers with this username);
           ListOfComputers = list;

        }

    }

    public Computer {
       private String name;
       private String owner;
       get/set/constructor


    }



    If you want to make your object persistent, your object can only
    contain fields which are known to castor (see castor website
    for supprted types). Hashmap and map are NOT supported yet (or
    they do not work as expected). For every object you have to write
    a xml mapping file so that castor knows how to save it (true for
    rdbms where you also have to create the databasetable, partly true
    for xml, you don't have to write a mapping file, but then the xml
    output looks ugly)

    As far as I understood the idea behind all this if you are constructing
    objects with relaction to other objects, not just including a field
    CustomerID there but include the customerobject by itself. I guess
    this is somewhat memory intense, but with that it makes perfectly sense
    with object/relational mappers and this is the way todo it, because
    you can't make classical sql joins but you have to query the (sub)object
    directly. Thats why this is Object Query Language and not SQL.
    -->
</chapter>