<!--

<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

    Author:     Jason Novotny
    Version:    $Id$
-->

<chapter id="actionmodel">
    <title>The GridSphere Action Provider Model</title>
    <para>
        As an advanced feature, GridSphere enhances the existing Portlet API with
        an Action Portlet Provider model for developing more sophisticated portlets.
    </para>

   <sect1 id="actionmodel.intro"><title>The ActionPortlet</title>
        <para>
        As described previously and in the Reference Guide, portlet development generally involves
        the implementation of an actionPerformed method and the doXXX render methods. In the general
        portlet lifecycle, the doView is invoked initially (when there is no inital action) which can
        produce output by using the &PortletResponse; to write directly to the output stream or by
        using the &PortletContext; to include a Java Server Page (JSP) used for presentation. In the
        typical case, the presentation of a portlet will consist of standard HTML elements including forms,
        checkboxes, input fields, submit buttons and other elements. Certain elements including
        hyperlinks, forms and submit buttons will generate actions that are trapped and used in the
        actionPerformed method of a portlet. The &ActionEvent; object available in the actionPerformed
        method of the portlet is used to obtain the name of the action that occurred. Once you start
        to develop more sophisticated portlets using the standard portlet API, you soon discover that
        the actionPerformed method contains a lot of the following logic:
            <programlisting>
            public actionPerformed(ActionEvent event) throws PortletException  {
                String actionName = event.getAction().getName();
                if (actionname.equals("dothis")) {
                    doThis();
                } else if (actionname.equals("dothat")) {
                    doThat();
                } else if ....

                }
            }
            </programlisting>
        As you can see, the actionPerformed method can potentially contain a lot of branching logic
        that makes the code less readable.
        </para>
       <para>
        In the GridSphere Action Provider model, the &ActionPortlet; acts as an intelligent dispatcher
        that hides the above branching logic from a portlet developer by following a simple convention:
        The action method invoked is defined by the action name of the HTML action element. So in the
        case of a form or submit button, a method name is defined
        that will be invoked by the portlet that subclasses from &ActionPortlet;. Hence, if an action
        such as <methodname>getStockQuotes</methodname>() is defined in the  name of the submit button
        in the presentation, this will trigger the <methodname>getStockQuotes</methodname>() method to be
        invoked by a <classname>StockQuotePortlet</classname> which subclasses from &ActionPortlet;
       </para>
       <para>
        The &ActionPortlet; provides a few additional helper methods that are used for portlet navigation.
        The <methodname>getNextState</methodname> and <methodname>setNextState</methodname> methods are used
        after the completion of an action method to set the next presentation page that should be rendered.
        The page can be specified as either a JSP file or another render method that will get invoked (which
        can then call setNextState with a supplied JSP page to perform an include of a JSP page upon completion.)
        The following sample code illustrates how this works:
           <programlisting>
               public void doThis(FormEvent event)
                    // perform some business logic
                    Portlet req = event.getPortletRequest();
                    setNextState(req, "dothis.jsp");

                    // OR

                    setNextState(req, "renderThis");
               }

               public void renderThis(PortletRequest req, PortletResponse res) {
                    getPortletConfig().getContext().include("dothis.jsp", req, res);
               }
           </programlisting>
        In both cases the result is the same. Either the next page is set to a JSP which will
        get rendered, or the <methodname>renderThis</methodname> method is invoked which will include the same JSP page.
        A recommended approach is to use a portlet render method if additional logic needs to be performed such that
        the JSP page that is finally included (if any at all) is used purely for presentation and includes the
        minimum amount of logic as possible.
       </para>
       <para>
           In the previous example, you can see that the action methods provide the portlet developer with a
           &FormEvent; object instead of the standard &ActionEvent; object that is used in the
           <methodname>actionPerformed</methodname> method. Under the Action Portlet provider model,
           the &FormEvent; is a decorator for an &ActionEvent; and provides additional methods for interacting
           with forms as explained in the next section.
       </para>
   </sect1>

    <sect1 id="beansandtags"><title>Forms, Beans and Tags</title>
    <para>
    While the &ActionPortlet; makes development easier by handling the dispatching logic necessary for
    complex portlet navigation and action event handling, GridSphere provides additional utilities to make the
    development of portlet presentation easier by borrowing from the visual programming paradigm. The
    design of useful portlet interfaces lies in the domain of JSP/HTML/CSS/DHTML development. As anyone with
        experience in user interface design knows, HTML is a very poor substitute for the widget-rich toolkits and
    frameworks one would get by using Swing, Visual Basic or any other graphics toolkit. To make developing web
        user interfaces easier for non-graphic design professionals, we have wrapped most standard HTML elements
    into a reusable Java Tag library, known as the Portlet User Interface (UI) tag library. The UI tags seek to provide
    more feature rich visual components that are configured with a default look and feel using CSS internally, so that
        portlet developers need not invest a lot of time in CSS development for decent looking web interfaces.
        See the Portlet UI Tag Reference Guide for more information on tag usage.
        The following example illustrates how the Portlet UI tag library would be used in a presentation JSP to
        construct a form:
        <programlisting>
      <![CDATA[
<ui:form>
    <ui:panel>
        <ui:frame>
            <ui:tablerow>
                <ui:tablecell width="100">
                    <ui:text key="COMPANY"/>
                </ui:tablecell>
                <ui:tablecell width="60">
                    <ui:textfield beanId="company" size="20" maxlength="20"/>
                </ui:tablecell>
                <ui:tablecell/>
            </ui:tablerow>
        </ui:frame>

        <ui:frame>
            <ui:tablerow>
                <ui:tablecell width="100">
                    <ui:actionsubmit action="getQuote" name="login" key="QUOTE_ACTION"/>
                </ui:tablecell>
                <ui:tablecell/>
            </ui:tablerow>
        </ui:frame>
    </ui:panel>
</ui:form>]]>
        </programlisting>

    </para>
        <para>
    In this example, a form is created to construct a stock quote query based upon a user's
    specified company. The user interface composed of panels that act as
    containers for frames. The underlying HTML uses tables and CSS. A frame contains one
    or more nested tablerow tags which in turn contain tablecell tags. A text tag is used to
    display localized text that is specified in a properties file.
    </para>
    <para>
        Portlet actions can be created by using <emphasis>ActionLink</emphasis> or
        <emphasis>ActionSubmit</emphasis> as shown in the following code snippet:
        <programlisting>
        &lt;ui:actionlink action="doActionLink" key="ACTION"/&gt;

        &lt;ui:actionsubmit action="doActionSubmit key="SUBMIT/&gt;
        </programlisting>
        An actionsubmit tag can be nested inside a form tag as well. In addition one or more
        actionparam tags can be nested inside an actionlink, actionsubmit or actionform tag to create
        action parameters that can be made availalble to the appropriate action method of the portlet as
        shown:
            <programlisting>
            <![CDATA[
            <ui:actionlink action="doActionLink" key="ACTION">
                <ui:actionparam name="aname" value="avalue"/>
            </ui:actionlink>]]>
            </programlisting>
        In this example, the portlet, call it SimplePortlet,  will have the following methods as shown:

        <programlisting>
           public class SimplePortlet extends ActionPortlet {

               public void doActionLink(FormEvent event) {
                    log.debug("in doActionLink");
               }

               public void doActionSubmit(FormEvent event) {
                    log.debug("in doActionSubmit");
               }

           }
        </programlisting>
        Now when an action is triggered from the user interface, the corresponding
        method is called in the portlet and can perform the required business logic before
        rendering the presentation. At the end of an action method, a portlet developer
        calls the <methodname>setNextState</methodname> method to set the presentation method
        or a JSP to be included. The following shows how the actionlink can be used to display a
        new view consisting of some text:
             <programlisting>
           public class SimplePortlet extends ActionPortlet {

               // action methods
               public void doActionLink(FormEvent event) {
                    log.debug("in doActionLink");
                    setNextState(event.getPortletRequest(), "displayMessage");
               }

               public void doActionSubmit(FormEvent event) {
                    log.debug("in doActionSubmit");
               }

               // presentation methods
               public void displayMessage(FormEvent event) {
                  PrintWriter out = event.getPortletResponse().getWriter();
                  out.println("you just hit an actionlink");
               }

           }
        </programlisting>
        In this example, a JSP could have been specified instead of a method. Generally, the
        presentation methods are used for performing any additional logic before the portlet is
        rendered, such as placing variables in the request or session, or usage of the portlet UI
        tag beans.
        </para>
        <para>
         The Portlet UI tag beans complement the UI tag library by providing a portlet developer
         with a visual bean library for creating dynamic user interfaces and obtaining information
         useful for performing business logic. The stock quote example earlier could be much more
         sophisticated using radiobuttons, checkboxes, and other HTML input elements that have been
         wrapped by the ui tag library. The following example, view.jsp, shows how a form is constructed to
         take user input and display the results.
         <programlisting>
             &lt;ui:form&gt;
             &lt;ui:textfield beanid="mybean" value="Empty right now"/&gt;
             &lt;ui:text beanId="msg" value="Nothing entered yet"/&gt;
             &lt;ui:actionsubmit action="doActionSubmit" value="Display"/&gt;
             &lt;/ui:form&gt;
         </programlisting>
         Now the <methodname>doActionForm</methodname> method can retrieve the textfield bean by doing the following:
                <programlisting>

               public void doActionForm(FormEvent event) {
                    // get text field input
                    TextFieldBean mybean = event.getTextFieldBean("mybean");
                    String value = mybean.getValue();

                    // set textbean message to entered text
                    TextBean tb = event.getTextBean("msg");
                    tb.setValue(value);

                    setNextState(event.getPortletRequest(), "simple.jsp");
               }

        </programlisting>
        Now when the JSP is displayed again, the text bean will contain the new value. The &FormEvent;
        provides various helper methods for retrieving beans from the corresponding tags and makes the
        construction and manipulation of web interfaces more consistent than using HTML/JSP alone. Please refer to the
        Portlet UI Tag Library Reference for more details on tag and bean usage.
    </para>
    <para>
    Finally, putting the simple portlet together requires that default views are set. The ActionPortlet
    defines the following variables to define the default presentation methods or JSPs:
    <emphasis>DEFAULT_VIEW_PAGE</emphasis>, <emphasis>DEFAULT_EDIT_PAGE</emphasis>,
    <emphasis>DEFAULT_CONFIGURE_PAGE</emphasis> and <emphasis>DEFAULT_HELP_PAGE</emphasis>. All necessary default presentation
    should be configured in the init method of the portlet as shown:
        <programlisting>
            public void init(PortletConfig config) throws UnavailableException {
                super.init(config);
                DEFAULT_VIEW_PAGE = "simple/view.jsp";
                DEFAULT_CONFIGURE_PAGE = "simple/config.jsp";
            }
        </programlisting>
    </para>
    <para>
     The GridSphere action model provides portlet developers with a higher level approach to
     complex portlet development and offers a sophisticated ui tag and visual bean library as well
     as built-in dispatching support for the execution of action methods and managing presentation.
    </para>
   </sect1>
</chapter>