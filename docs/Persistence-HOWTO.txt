Everything you need to know about persistence.

Until now the PersistenceManager (PM) is castor based.

I'm providing functions to easily create/update/restore/delete
object from storage.

- create : creates a new object
- restoreObject : restores a single object matchin the query in
  rdbms (aka the first found object) , in xml one xml files 
  represents one object it will return the object
- restoreList : returns a list object conntaining all objects
  which matches the query (rdbms) in xml it returns a list with
  just on object (maybe never used this function, I just put it
  there)
- delete : deletes object from storage (rdbms), in xml it does nothing
  until now (should delete the file)
- update : updates the object on the storage

These methods are in the interface, further more there is

- setConnectionURL : in rdbms sets the filename of the database.xml file,
  in xml sets the filename to the xml file where you want to have your 
  data saved


In rdbms you need two more methods:

- setDatabaseName : which database to save to (like 'portal')
- setQuery : sets the actual query

The CRUD methods are throwing exception, every one throws 
ConfigurationException if the configuration was not ok (like
connectionURL was not set) and Create/Restore/Update/Delete
Exception (only in the corresponding methods of course)

If you want to store your data in a rdbms (like mysql) and want
to not direclty code in castor syntax you have to extend from
BaseObject (or implement the methods and variables there).
Every objects needs an ObjectID (Oid) and for castortransactions
the field timestamp is needed. For my classes I assume Oid and
timestamp exists in every class which should be saved to a rdbms.
You don't need this if you want to save to xml.
Fuurthermore you need to 'normalize' your classes to store them in 
a database and structures like vector and list are not directly
saved in the object itself but in a seperate table (since these
structures can only be represented in a database as a table and
table in table is not possible, but table with a reference to another
table). Let's assume you have an Object Users, with a vector
of computername of this user.

public class User {
   private String name;
   private Vector ListOfComputers;

   get/set...

}

The database table for user would look like:

Oid varchar(255), Name varchar(255)...but waht about the list?

The ListOfComputers must be stored in a sperate table, actually it should
have the name 'Computer'.

Oid varchar(255), Name varachr(255), UserOid varchar(255)

So every entry in the table ListOfComputers would have
an Oid, the name of the computer and the reference to the User.
What does this mean for the User Object, it should look like this:

public class User {
    private String name;
    private Vector ListOfComputers;

    get/set Name

    public void addComputer(String name) {
       Computer comp = new Computer(name);
       comp.setOwner(this.name);
       persistencemanger.save(comp);       
    }

    public void getComputers() {

       Vector list = persistencemanager.getList(query database for all computers with this username);
       ListOfComputers = list;

    } 

}

public Computer {
   private String name;
   private String owner;
   get/set/constructor

   
}
 

  
If you want to make your object persistent, your object can only
contain fields which are known to castor (see castor website
for supprted types). Hashmap and map are NOT supported yet (or
they do not work as expected). For every object you have to write
a xml mapping file so that castor knows how to save it (true for
rdbms where you also have to create the databasetable, partly true
for xml, you don't have to write a mapping file, but then the xml
output looks ugly)

As far as I understood the idea behind all this if you are constructing
objects with relaction to other objects, not just including a field
CustomerID there but include the customerobject by itself. I guess
this is somewhat memory intense, but with that it makes perfectly sense
with object/relational mappers and this is the way todo it, because
you can't make classical sql joins but you have to query the (sub)object
directly. Thats why this is Object Query Language and not SQL.

