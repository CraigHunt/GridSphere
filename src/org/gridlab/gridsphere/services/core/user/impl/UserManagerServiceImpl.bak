/*
 * Created by IntelliJ IDEA.
 * User: russell
 * Date: Jan 31, 2003
 * Time: 3:58:16 AM
 * To change template for new interface use
 * Code Style | Class Templates options (Tools | IDE Options).
 */
package org.gridlab.gridsphere.services.user.impl;

import org.gridlab.gridsphere.services.security.password.InvalidPasswordException;
import org.gridlab.gridsphere.services.user.impl.GridSphereUserManager;
import org.gridlab.gridsphere.services.user.UserManagerService;
import org.gridlab.gridsphere.services.user.AccountRequest;
import org.gridlab.gridsphere.services.user.InvalidAccountRequestException;
import org.gridlab.gridsphere.core.mail.MailMessage;
import org.gridlab.gridsphere.portlet.User;
import org.gridlab.gridsphere.portlet.service.PortletService;
import org.gridlab.gridsphere.portlet.service.PortletServiceUnavailableException;
import org.gridlab.gridsphere.portlet.service.spi.PortletServiceProvider;
import org.gridlab.gridsphere.portlet.service.spi.PortletServiceConfig;

import java.util.List;

public class UserManagerServiceImpl implements UserManagerService, PortletServiceProvider {

    private GridSphereUserManager userManager = GridSphereUserManager.getInstance();

    public UserManagerServiceImpl() {

    }

<<<<<<< UserManagerServiceImpl.java
    private void initAccessControl(PortletServiceConfig config)
            throws PortletServiceUnavailableException {
        log.info("Entering initGroups()");
        // Creating groups
        initGroup(PortletGroup.SUPER);
        initGroup(PortletGroup.BASE);
        log.info("Entering initServices()");
    }

    private void initGroup(PortletGroup group) {
        if (group instanceof SportletGroup) {
            initSportletGroup((SportletGroup) group);
        }
    }

    private void initSportletGroup(SportletGroup group) {
        String groupName = group.getName();
        SportletGroup testGroup = getSportletGroupByName(groupName);
        if (testGroup == null) {
            log.info("Creating group " + groupName);
            try {
                pm.create(group);
            } catch (PersistenceManagerException e) {
                String msg = "Error creating portlet group " + groupName;
                log.error(msg, e);
            }
        } else {
            String groupId = testGroup.getID();
            log.info("Setting group " + groupName + " id to " + groupId);
            group.setID(groupId);
        }
    }

    private void initRootUser(PortletServiceConfig config)
            throws PortletServiceUnavailableException {
        log.info("Entering initRootUser()");
        /** 1. Retrieve root user properties **/
        // Login name
        String loginName = config.getInitParameter("loginName", "root").trim();
        log.info("Root user login name = " + loginName);
        /** 2. Create root user account if doesn't exist **/
        User rootUser = getUserByUserName(loginName);
        if (rootUser == null) {
            /* Retrieve root user properties */
            log.info("Retrieving root user properties");
            String familyName = config.getInitParameter("familyName", "User").trim();
            log.info("Root user family name = " + familyName);
            String givenName = config.getInitParameter("givenName", "Root").trim();
            log.info("Root user given name = " + givenName);
            String fullName = config.getInitParameter("fullName", "").trim();
            log.info("Root user full name = " + givenName);
            String organization = config.getInitParameter("organization", "GridSphere").trim();
            log.info("Root user organization = " + organization);
            String emailAddress = config.getInitParameter("emailAddress", "root@localhost").trim();
            log.info("Root user email address = " + emailAddress);
            String password = config.getInitParameter("password", "").trim();
            if (password.equals("")) {
                log.warn("Root user password is blank. Please create a password as soon as possible!");
            }
            /* Set root user profile */
            AccountRequest rootRequest = createAccountRequest();
            rootRequest.setUserID(loginName);
            rootRequest.setFamilyName(familyName);
            rootRequest.setGivenName(givenName);
            rootRequest.setFullName(fullName);
            rootRequest.setOrganization(organization);
            rootRequest.setEmailAddress(emailAddress);
            /* Set root user password */
            rootRequest.setPasswordValue(password);
            rootRequest.setPasswordDateExpires(null);
            rootRequest.setPasswordValidation(false);
            /* Create root user account */
            log.info("Creating root user account.");
            try {
                submitAccountRequest(rootRequest);
                approveAccountRequest(rootRequest);
            } catch (InvalidAccountRequestException e) {
                log.error("Unable to create account for root user", e);
                throw new PortletServiceUnavailableException(e.getMessage());
            } catch (InvalidPasswordException e) {
                log.error("Unable to create account for root user", e);
                throw new PortletServiceUnavailableException(e.getMessage());
            }
            /* Retrieve root user object */
            rootUser = getUserByUserName(loginName);
            /* Grant super role to root user */
            log.info("Granting super role to root user.");
            grantSuperRole(rootUser);
        } else {
            log.info("Root user exists.");
            if (!hasSuperRole(rootUser)) {
                log.info("Root user does not have super role! Granting now...");
                /* Grant super role to root user */
                grantSuperRole(rootUser);
            }
        }
        log.info("Exiting initRootUser()");
    }

    public void destroy() {
        log.info("Calling destroy()");
    }

    public User login(String username, String password)
            throws AuthenticationException {
        User user = getAuthUser(username);
        AuthenticationException ex = null;
        Iterator modules = this.authenticationModules.iterator();
        while (modules.hasNext()) {
            AuthenticationModule module = (AuthenticationModule) modules.next();
            try {
                module.authenticate(user, password);
            } catch (AuthenticationException e) {
                if (ex == null) {
                    ex = e;
                }
            }
        }
        if (ex != null) {
            throw ex;
        }
        return user;
    }

    public User login(Map parameters)
             throws AuthenticationException {
         User user = getAuthUser(parameters);
         AuthenticationException ex = null;
         Iterator modules = this.authenticationModules.iterator();
         while (modules.hasNext()) {
             AuthenticationModule module = (AuthenticationModule) modules.next();
             try {
                 module.authenticate(user, parameters);
             } catch (AuthenticationException e) {
                 if (ex == null) {
                     ex = e;
                 }
             }
         }
         if (ex != null) {
             throw ex;
         }
         return user;
    }

    private User getAuthUser(Map parameters)
            throws AuthenticationException {
        String username = (String) parameters.get("username");
        return getAuthUser(username);
    }

    private User getAuthUser(String loginName)
            throws AuthenticationException {
        log.debug("Attempting to retrieve user " + loginName);
        if (loginName == null) {
            AuthenticationException ex = new AuthenticationException();
            ex.putInvalidParameter("username", "No username provided.");
            throw ex;
        }
        User user = getUserByUserName(loginName);
        if (user == null) {
            log.debug("Unable to retrieve user " + loginName);
            AuthenticationException ex = new AuthenticationException();
            ex.putInvalidParameter("username", "Invalid username provided.");
            throw ex;
        }
        log.debug("Successfully retrieved user " + loginName);
        return user;
=======
    /**
     * Initializes the portlet service.
     * The init method is invoked by the portlet container immediately after a portlet service has
     * been instantiated and before it is passed to the requestor.
     *
     * @param config the service configuration
     * @throws PortletServiceUnavailableException if an error occurs during initialization
     */
    public void init(PortletServiceConfig config) throws PortletServiceUnavailableException {
        userManager.init(config);
>>>>>>> 1.40
    }

<<<<<<< UserManagerServiceImpl.java
    private List selectAccountRequests(String criteria) {
        String oql = "select accountRequest from "
                   + this.jdoAccountRequest
                   + " accountRequest "
                   + criteria;
        try {
            return pm.restoreList(oql);
        } catch (PersistenceManagerException e) {
            String msg = "Error retrieving account request";
            log.error(msg, e);
            return new Vector();
        }
=======
    /**
     * The destroy method is invoked by the portlet container to destroy a portlet service.
     * This method must free all resources allocated to the portlet service.
     */
    public void destroy() {}

    /**
      * Administrators can retrieve all pending account request
      *
      * @return a list of pending account requests
      */
    public List selectAccountRequests(String criteria) {
        return userManager.selectAccountRequests(criteria);
>>>>>>> 1.40
    }

    /**
      * Administrators can retrieve all pending account request
      *
      * @return a list of pending account requests
      */
    public List getAccountRequests() {
        return userManager.getAccountRequests();
    }

    /**
     * Returns the account request for the given user id
     *
     * @param user id of account request
     * @return account request for given user id
     */
    public AccountRequest getAccountRequest(String oid) {
        return userManager.getAccountRequest(oid);
    }

    /**
      * Create a new account request. An internal ID is assigned the request
      *
      * @return a new AccountRequest
      */
    public AccountRequest createAccountRequest() {
        return userManager.createAccountRequest();
    }

    /**
      * Create a change account request. An internal ID is assigned the request
      *
      * @return a new AccountRequest
      */
    public AccountRequest createAccountRequest(User user) {
<<<<<<< UserManagerServiceImpl.java
        AccountRequestImpl request = new AccountRequestImpl();
        request.setID(user.getID());
        request.setUserName(user.getUserName());
        request.setFamilyName(user.getFamilyName());
        request.setGivenName(user.getGivenName());
        request.setFullName(user.getFullName());
        request.setOrganization(user.getOrganization());
        request.setEmailAddress(user.getEmailAddress());
        return request;
=======
        return userManager.createAccountRequest(user);
>>>>>>> 1.40
    }

    /**
     * Validate account request.
     *
     * @param request the <code>AccountRequest</code> to submit
     */
    public void validateAccountRequest(AccountRequest request)
            throws InvalidAccountRequestException, InvalidPasswordException {
        userManager.validateAccountRequest(request);
    }

    /**
     * Submit the account request to the queue for administrative approval
     *
     * @param request the <code>AccountRequest</code> to submit
     */
    public void submitAccountRequest(AccountRequest request)
            throws InvalidAccountRequestException, InvalidPasswordException {
        userManager.submitAccountRequest(request);
    }

     /**
      * Submit the account request to the queue for administrative approval
      *
      * @param request the <code>AccountRequest</code> to submit
      */
    public void submitAccountRequest(AccountRequest request, MailMessage mailMessage)
            throws InvalidAccountRequestException, InvalidPasswordException {
         userManager.submitAccountRequest(request, mailMessage);
     }

    /**
      * Approve a new or modified account request.
      * If mailMessage is non-null, a mail message will be sent out to the account requestor
      *
      * @param request the <code>AccountRequest</code> to approve
      * @param mailMessage the <code>MailMessage</code> to use for notification
      */
    public User approveAccountRequest(AccountRequest request) {
        return userManager.approveAccountRequest(request);
    }

    /**
      * Approve a new or modified account request.
      * If mailMessage is non-null, a mail message will be sent out to the account requestor
      *
      * @param request the <code>AccountRequest</code> to approve
      * @param mailMessage the <code>MailMessage</code> to use for notification
      */
    public User approveAccountRequest(AccountRequest request, MailMessage mailMessage) {
        return userManager.approveAccountRequest(request, mailMessage);
    }

    /**
      * Approve a new or modified account request.
      * If mailMessage is non-null, a mail message will be sent out to the account requestor
      *
      * @param request the <code>AccountRequest</code> to approve
      * @param mailMessage the <code>MailMessage</code> to use for notification
      */
    public void denyAccountRequest(AccountRequest request) {
        userManager.denyAccountRequest(request);
    }

    /**
      * Approve a new or modified account request.
      * If mailMessage is non-null, a mail message will be sent out to the account requestor
      *
      * @param request the <code>AccountRequest</code> to approve
      * @param mailMessage the <code>MailMessage</code> to use for notification
      */
    public void denyAccountRequest(AccountRequest request, MailMessage mailMessage) {
        userManager.denyAccountRequest(request, mailMessage);
    }

    /**
      * Approve a new or modified account request.
      * If mailMessage is non-null, a mail message will be sent out to the account requestor
      *
      * @param request the <code>AccountRequest</code> to approve
      * @param mailMessage the <code>MailMessage</code> to use for notification
      */
    public void deleteAccount(User user) {
        userManager.deleteAccount(user);
    }

    /**
      * Approve a new or modified account request.
      * If mailMessage is non-null, a mail message will be sent out to the account requestor
      *
      * @param request the <code>AccountRequest</code> to approve
      * @param mailMessage the <code>MailMessage</code> to use for notification
      */
    public void deleteAccount(User user, MailMessage mailMessage) {
        userManager.deleteAccount(user, mailMessage);
    }

<<<<<<< UserManagerServiceImpl.java
    private List selectUsers(String criteria) {
        String oql = "select user from "
                   + this.jdoUser
                   + " user "
                   + criteria;
        try {
            return pm.restoreList(oql);
        } catch (PersistenceManagerException e) {
            String msg = "Error retrieving users with criteria " + criteria;
            log.error(msg, e);
            return new Vector();
        }
=======
    /**
     * Return a list of all portal users
     *
     * @return a list containing all Role objects
     */
    public List selectUsers(String criteria) {
        return userManager.selectUsers(criteria);
>>>>>>> 1.40
    }

    /**
      * Administrators can retrieve all pending account request
      *
      * @return a list of pending account requests
      */
    public List getUsers() {
        return userManager.getUsers();
    }

    /**
      * Retrieves a user object with the given username from this service.
      * Requires a user with the "super user" AccessRights, since this
      * by-passes the normal login mechanism of retrieving a user object.
      *
      * @param User The super user requesting the user object
      * @param String The user name or login id of the user in question
      */
    public User getUser(String id) {
        return userManager.getUser(id);
    }

<<<<<<< UserManagerServiceImpl.java
    public User getUserByUserName(String loginName) {
        return getSportletUserImplByLoginName(loginName);
    }

    private SportletUserImpl getSportletUserImpl(String id) {
        return selectSportletUserImpl("where user.ObjectID=\"" + id + "\"");
    }

    private SportletUserImpl getSportletUserImplByLoginName(String loginName) {
        return selectSportletUserImpl("where user.UserID=\"" + loginName + "\"");
    }

    private SportletUserImpl selectSportletUserImpl(String criteria) {
        String oql = "select user from "
                   + jdoUser
                   + " user "
                   + criteria;
        try {
            return (SportletUserImpl)pm.restoreObject(oql);
        } catch (PersistenceManagerException e) {
            String msg = "Error retrieving user with criteria " + criteria;
            log.error(msg, e);
            return null;
        }
    }

    private SportletUserImpl editSportletUserImpl(AccountRequest request) {
        /* TODO: Account request id should not be same as user id */
        String userID = request.getID();
        SportletUserImpl user = getSportletUserImpl(userID);
        if (user == null) {
            user = new SportletUserImpl();
            user.setID(userID);
        }
        user.setUserName(request.getUserName());
        user.setFamilyName(request.getFamilyName());
        user.setGivenName(request.getGivenName());
        user.setFullName(request.getFullName());
        user.setOrganization(request.getOrganization());
        user.setEmailAddress(request.getEmailAddress());
        return user;
    }

    private void saveSportletUserImpl(SportletUserImpl user) {
        // Create or update user
        if (existsSportletUserImpl(user)) {
            try {
                pm.update(user);
            } catch (PersistenceManagerException e) {
                String msg = "Error updating user";
                log.error(msg, e);
            }
        } else {
            try {
                pm.create(user);
            } catch (PersistenceManagerException e) {
                String msg = "Error creating user";
                log.error(msg, e);
            }
        }
    }

    private void deleteSportletUserImpl(SportletUserImpl user) {
        try {
            pm.delete(user);
        } catch (PersistenceManagerException e) {
            String msg = "Error deleting user";
            log.error(msg, e);
        }
    }

    public boolean existsUserWithID(String userID) {
        String criteria = "where user.ObjectID=\"" + userID + "\"";
        return existsSportletUserImpl(criteria);
=======
    /**
      * Retrieves a user object with the given username from this service.
      * Requires a user with the "super user" AccessRights, since this
      * by-passes the normal login mechanism of retrieving a user object.
      *
      * @param User The super user requesting the user object
      * @param String The user name or login id of the user in question
      */
    public User getUserByLoginName(String loginName) {
        return userManager.getUserByLoginName(loginName);
>>>>>>> 1.40
    }

<<<<<<< UserManagerServiceImpl.java
    public boolean existsUserName(String loginName) {
        String criteria = "where user.UserID=\"" + loginName + "\"";
        return existsSportletUserImpl(criteria);
    }

    private boolean existsSportletUserImpl(SportletUserImpl user) {
        String criteria = "where user.ObjectID=\"" + user.getOid() + "\"";
        return existsSportletUserImpl(criteria);
    }

    private boolean existsSportletUserImpl(String criteria) {
        String oql = "select user.ObjectID from "
                   + jdoUser
                   + " user "
                   + criteria;
        try {
            return (pm.restoreObject(oql) != null);
        } catch (PersistenceManagerException e) {
            String msg = "Error retrieving account request";
            log.error(msg, e);
        }
        return false;
    }

    public List getGroupRequests() {
        String criteria = "";
        return selectGroupRequests(criteria);
    }

    public List getGroupRequests(User user) {
        String criteria = "where groupRequest.user=\"" + user.getID() + "\"";
        return selectGroupRequests(criteria);
    }

    public List getGroupRequests(PortletGroup group) {
        String criteria = "where groupRequest.group=\"" + group.getID() + "\"";
        return selectGroupRequests(criteria);
    }

    public List getGroupRequestsForGroups(List groups) {
        List sumGroupRequests = null;
        for (int ii = 0; ii < groups.size(); ++ii) {
            PortletGroup group = (PortletGroup)groups.get(ii);
            List groupRequests = getGroupRequests(group);
            sumGroupRequests.add(groupRequests);
        }
        return sumGroupRequests;
    }

    private List selectGroupRequests(String criteria) {
        String oql = "select groupRequest from "
                   + jdoGroupRequest
                   + " groupRequest "
                   + criteria;
        try {
            return pm.restoreList(oql);
        } catch (PersistenceManagerException e) {
            String msg = "Error retrieving account request";
            log.error(msg, e);
            return new Vector();
        }
    }

    public GroupRequest getGroupRequest(String id) {
        return getGroupRequestImpl(id);
    }

    private GroupRequestImpl getGroupRequestImpl(String id) {
        String criteria = "where groupRequest.ObjectID=\"" + id + "\"";
        return selectGroupRequestImpl(criteria);
    }

    private GroupRequestImpl selectGroupRequestImpl(String criteria) {
        String oql = "select groupRequest from "
                   + jdoGroupRequest
                   + " groupRequest "
                   + criteria;
        try {
            return (GroupRequestImpl)pm.restoreObject(oql);
        } catch (PersistenceManagerException e) {
            String msg = "Error retrieving account request";
            log.error(msg, e);
            return null;
        }
    }

    private boolean existsGroupRequest(GroupRequest request) {
       GroupRequestImpl requestImpl = (GroupRequestImpl)request;
       String oql = "select groupRequest.ObjectID from "
                  + jdoGroupRequest
                  + " groupRequest where groupRequest.ObjectID="
                  + requestImpl.getOid();
       try {
           return (pm.restoreObject(oql) != null);
       } catch (PersistenceManagerException e) {
           String msg = "Error retrieving account request";
           log.error(msg, e);
       }
       return false;
    }

    private void saveGroupRequest(GroupRequest request) {
        // Create or update access request
        if (!existsGroupRequest(request)) {
            try {
                pm.create(request);
            } catch (PersistenceManagerException e) {
                String msg = "Error creating access request";
                log.error(msg, e);
            }
        }
    }

    private void deleteGroupRequest(GroupRequest request) {
        try {
            pm.delete(request);
        } catch (PersistenceManagerException e) {
            String msg = "Error deleting access request";
            log.error(msg, e);
        }
    }

    public GroupRequest createGroupRequest(User user) {
        GroupRequest request = new GroupRequestImpl();
        request.setUser(user);
        return request;
    }

    public void submitGroupRequest(GroupRequest request)
            throws InvalidGroupRequestException {
        submitGroupRequest(request, null);
    }

    public void submitGroupRequest(GroupRequest request, MailMessage mailMessage)
            throws InvalidGroupRequestException {
        if (request instanceof AccountRequestImpl) {
            // First validate accesss request
            validateGroupRequest(request);
            // Then save account request if not already saved
            if (!existsGroupRequest(request)) {
                try {
                    pm.create(request);
                } catch (PersistenceManagerException e) {
                    String msg = "Error saving account request";
                    log.error(msg, e);
                }
            }
            // Send message if not null
        }
    }

    public void validateGroupRequest(GroupRequest request)
            throws InvalidGroupRequestException {
        PortletGroup group = request.getGroup();
        PortletRole role = request.getRole();
        // If role is super but group isn't, throw invalid access request exception
        if (role.equals(PortletRole.SUPER) && (! group.equals(PortletGroup.SUPER) )) {
            String msg = "Super role can only exist in super group.";
            log.info(msg);
            throw new InvalidGroupRequestException(msg);
        // If group is super but role isn't, throw invalid access request exception
        } else if (group.equals(PortletRole.SUPER) && (! role.equals(PortletRole.SUPER) )) {
            String msg = "Super group can only contain super role.";
            log.info(msg);
            throw new InvalidGroupRequestException(msg);
        } else if (! (role.equals(PortletRole.ADMIN) ||
                      role.equals(PortletRole.USER)  ||
                      role.equals(PortletRole.GUEST) )) {
            String msg = "Portlet role [" + role + "] not recognized.";
            log.info(msg);
            throw new InvalidGroupRequestException(msg);
        }
    }

    public void approveGroupRequest(GroupRequest request) {
        approveGroupRequest(request, null);
    }

    public void approveGroupRequest(GroupRequest request, MailMessage mailMessage) {
        if (request instanceof GroupRequestImpl) {
            // Get request attributes
            User user = request.getUser();
            PortletGroup group = request.getGroup();
            String action = request.getAction();
            // Perform requested action
            if (action.equals(GroupRequest.ACTION_ADD)) {
                PortletRole role = request.getRole();
                addUserToGroup(user, group, role);
            } else {
                removeUserFromGroup(user, group);
            }
            // Delete account request
            deleteGroupRequest(request);
            // Send message if not null
        }
    }

    public void denyGroupRequest(GroupRequest request) {
        denyGroupRequest(request, null);
    }

    public void denyGroupRequest(GroupRequest request, MailMessage mailMessage) {
        if (request instanceof GroupRequestImpl) {
            // Delete account request
            deleteGroupRequest(request);
            // Send message if not null
        }
    }

    public List getGroupEntries() {
        String criteria = "";
        return selectGroupEntries(criteria);
    }

    public List getGroupEntries(User user) {
        String criteria = "where groupEntry.user=\"" + user.getID() + "\"";
        return selectGroupEntries(criteria);
    }

    public List getGroupEntries(PortletGroup group) {
        String criteria = "where groupEntry.group=\"" + group.getID() + "\"";
        return selectGroupEntries(criteria);
    }

    public List getGroupEntriesForGroups(List groups) {
        List sumGroupEntries = null;
        for (int ii = 0; ii < groups.size(); ++ii) {
            PortletGroup group = (PortletGroup)groups.get(ii);
            List groupEntries = getGroupEntries(group);
            sumGroupEntries.add(groupEntries);
        }
        return sumGroupEntries;
    }

    private List selectGroupEntries(String criteria) {
        String oql = "select groupEntry from "
                   + jdoGroupEntry
                   + " groupEntry "
                   + criteria;
        try {
            return pm.restoreList(oql);
        } catch (PersistenceManagerException e) {
            String msg = "Error retrieving access right";
            log.error(msg, e);
            return new Vector();
        }
    }

    public GroupEntry getGroupEntry(String id) {
        String criteria = "where groupEntry.ObjectID=\"" + id + "\"";
        return selectGroupEntryImpl(criteria);
    }

    public GroupEntry getGroupEntry(User user, PortletGroup group) {
        return getGroupEntryImpl(user, group);
    }

    private GroupEntryImpl getGroupEntryImpl(User user, PortletGroup group) {
        String criteria = "where groupEntry.user=\"" + user.getID() + "\""
                        +  " and groupEntry.group=\"" + group.getID() + "\"";
        return selectGroupEntryImpl(criteria);
    }

    private GroupEntryImpl selectGroupEntryImpl(String criteria) {
        String oql = "select groupEntry from "
                   + jdoGroupEntry
                   + " groupEntry "
                   + criteria;
        try {
            return (GroupEntryImpl)pm.restoreObject(oql);
        } catch (PersistenceManagerException e) {
            String msg = "Error retrieving access right";
            log.error(msg, e);
            return null;
        }
    }

   private boolean existsGroupEntry(GroupEntry right) {
       GroupEntryImpl rightImpl = (GroupEntryImpl)right;
       String oql = "select groupEntry.ObjectID from "
                  + jdoGroupEntry
                  + " groupEntry where groupEntry.ObjectID="
                  + rightImpl.getOid();
       try {
           return (pm.restoreObject(oql) != null);
       } catch (PersistenceManagerException e) {
           String msg = "Error retrieving access right";
           log.error(msg, e);
       }
       return false;
    }

    private void saveGroupEntry(GroupEntry right) {
        // Create or update access right
        if (!existsGroupEntry(right)) {
            try {
                pm.create(right);
            } catch (PersistenceManagerException e) {
                String msg = "Error creating access right";
                log.error(msg, e);
            }
        }
    }

    private void deleteGroupEntry(GroupEntry right) {
        try {
            pm.delete(right);
        } catch (PersistenceManagerException e) {
            String msg = "Error deleting access right";
            log.error(msg, e);
        }
    }

    private void deleteGroupEntries(User user) {
        Iterator groupEntries = getGroupEntries(user).iterator();
        while (groupEntries.hasNext()) {
            GroupEntry groupEntry = (GroupEntry)groupEntries.next();
            deleteGroupEntry(groupEntry);
        }
    }

    public List getGroups() {
        return selectGroups("");
    }

    private List selectGroups(String criteria) {
        String oql = "select portletGroup from "
                   + jdoPortletGroup
                   + " portletGroup "
                   + criteria;
        try {
            return pm.restoreList(oql);
        } catch (PersistenceManagerException e) {
            String msg = "Error retrieving portlet groups";
            log.error(msg, e);
            return new Vector();
        }
    }

    public PortletGroup getGroup(String id) {
        return selectSportletGroup("where portletGroup.ObjectID=\"" + id + "\"");
    }

    public PortletGroup getGroupByName(String name) {
        return getSportletGroupByName(name);
    }

    private SportletGroup getSportletGroupByName(String name) {
        return selectSportletGroup("where portletGroup.Name=\"" + name + "\"");
    }

    private SportletGroup selectSportletGroup(String criteria) {
        String oql = "select portletGroup from "
                   + jdoPortletGroup
                   + " portletGroup "
                   + criteria;
        try {
            return (SportletGroup)pm.restoreObject(oql);
        } catch (PersistenceManagerException e) {
            String msg = "Error retrieving portlet groups";
            log.error(msg, e);
            return null;
        }
    }

    public boolean existsGroupWithName(String groupName) {
        return (getGroupByName(groupName) != null);
    }

    public PortletGroup createGroup(String groupName) {
        SportletGroup group = getSportletGroupByName(groupName);
        if (group == null) {
            group = new SportletGroup();
            group.setName(groupName);
            try {
                pm.create(group);
            } catch (PersistenceManagerException e) {
                String msg = "Error creating portlet group " + groupName;
                log.error(msg, e);
            }
        }
        return group;
    }

    public void deleteGroup(PortletGroup group) {
        try {
            pm.delete(group);
        } catch (PersistenceManagerException e) {
            String msg = "Error deleting portlet group";
            log.error(msg, e);
        }
    }

    public List getUsers(PortletGroup group) {
        String oql = "select groupEntry.user from "
                   + jdoGroupEntry
                   + " groupEntry where group=\""
                   + group.getID()
                   + "\"";
        try {
            return pm.restoreList(oql);
        } catch (PersistenceManagerException e) {
            String msg = "Error retrieving access right";
            log.error(msg, e);
            return new Vector();
        }
    }

    public List getUsersNotInGroup(PortletGroup group) {
        List usersNotInGroup = new Vector();
        Iterator allUsers = getUsers().iterator();
        while (allUsers.hasNext()) {
            User user = (User)allUsers.next();
            if (!isUserInGroup(user, group)) {
                usersNotInGroup.add(user);
            }
        }
        return usersNotInGroup;
    }

    public boolean isUserInGroup(User user, PortletGroup group) {
        return (getGroupEntry(user, group) != null);
    }

    public List getGroups(User user) {
        String oql = "select groupEntry.group from "
                   + jdoGroupEntry
                   + " groupEntry where user=\""
                   + user.getID()
                   + "\"";
        try {
            return pm.restoreList(oql);
        } catch (PersistenceManagerException e) {
            String msg = "Error retrieving access right";
            log.error(msg, e);
            return new Vector();
        }
    }

    public List getGroupsNotMemberOf(User user) {
        List groupsNotMemberOf = new Vector();
        Iterator allGroups = getGroups(user).iterator();
        while (allGroups.hasNext()) {
            PortletGroup group = (PortletGroup)allGroups.next();
            if (!isUserInGroup(user, group)) {
                groupsNotMemberOf.add(user);
            }
        }
        return groupsNotMemberOf;
=======
    /**
      * Checks to see if account exists for a user
      *
      * @param userID the user login ID
      * @return true if the user exists, false otherwise
      */
    public boolean existsUserWithLoginName(String loginName) {
        return userManager.existsUserWithLoginName(loginName);
>>>>>>> 1.40
    }

}
